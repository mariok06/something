def binary_to_decimal(b):
    """Convert binary string to decimal integer."""
    return int(b, 2) if b[0] == '0' else -int(b[1:], 2)

def decimal_to_binary(num, bits):
    """Convert decimal integer to binary string of fixed length."""
    if num >= 0:
        b = bin(num)[2:]
        return b.zfill(bits)
    else:
        # Two's complement for negative numbers
        b = bin((1 << bits) + num)[2:]
        return b[-bits:]

def non_restoring_division(dividend, divisor, bits):
    """
    Perform Non-Restoring Division on binary numbers.
    dividend, divisor : binary strings
    bits              : number of bits for quotient and remainder
    """

    # Convert to decimal
    A = 0
    M = int(divisor, 2)
    Q = int(dividend, 2)

    print(f"Initial Values:")
    print(f"A = {A:0{bits}b}, M = {M:0{bits}b}, Q = {Q:0{bits}b}\n")

    for step in range(bits):
        # Left shift A and Q
        A = (A << 1) | ((Q >> (bits - 1)) & 1)
        A &= (1 << bits) - 1  # limit to bits
        Q = (Q << 1) & ((1 << bits) - 1)

        # Subtract M
        A = A - M

        print(f"Step {step + 1}: After shift and subtract M:")
        print(f"A = {A:0{bits}b}, Q = {Q:0{bits}b}")

        if A < 0:
            # Restore and set Q0 = 0
            A = A + M
            Q = Q & ~1  # Set LSB to 0
            print(f"A negative â†’ Restored A = {A:0{bits}b}, Q0 = 0")
        else:
            # Set Q0 = 1
            Q = Q | 1
            print(f"A positive â†’ Keep A = {A:0{bits}b}, Q0 = 1")

        print()

    remainder = A
    quotient = Q

    print(f"Final Quotient (Q)  = {quotient:0{bits}b}")
    print(f"Final Remainder (A) = {remainder:0{bits}b}")

    return quotient, remainder


# Example usage
dividend = "1100"   # 12 in decimal
divisor = "0011"    # 3 in decimal
bits = 4

q, r = non_restoring_division(dividend, divisor, bits)

print("\nResult:")
print(f"Quotient  = {q:0{bits}b} ({q})")
print(f"Remainder = {r:0{bits}b} ({r})")
