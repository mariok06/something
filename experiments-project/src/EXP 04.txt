def booth_multiplication(m, q):
    # Convert to integers
    m = int(m, 2)
    q = int(q, 2)

    # Determine bit length based on the largest input
    n = max(len(bin(abs(m))) - 2, len(bin(abs(q))) - 2)

    # Two's complement helper
    def twos_complement(val, bits):
        if val < 0:
            val = (1 << bits) + val
        return val

    # Restore from two's complement
    def from_twos_complement(val, bits):
        if val & (1 << (bits - 1)):
            val -= (1 << bits)
        return val

    # Initialize variables
    A = 0
    Q = twos_complement(q, n)
    M = twos_complement(m, n)
    Q_1 = 0

    print(f"Initial values:")
    print(f"A: {A:0{n}b}, Q: {Q:0{n}b}, Q-1: {Q_1}, M: {M:0{n}b}\n")

    for i in range(n):
        print(f"Step {i + 1}:")
        last_bits = (Q & 1, Q_1)
        if last_bits == (0, 1):
            print("  Operation: A = A + M")
            A = (A + M) % (1 << n)
        elif last_bits == (1, 0):
            print("  Operation: A = A - M")
            A = (A - M) % (1 << n)

        # Arithmetic right shift of [A, Q, Q_1]
        A_Q_Q1 = (A << (n + 1)) | (Q << 1) | Q_1
        A_Q_Q1 >>= 1

        # Extract back A, Q, Q_1
        A = (A_Q_Q1 >> n + 1 - n) & ((1 << n) - 1)
        Q = (A_Q_Q1 >> 1) & ((1 << n) - 1)
        Q_1 = A_Q_Q1 & 1

        print(f"  A: {A:0{n}b}, Q: {Q:0{n}b}, Q-1: {Q_1}\n")

    # Combine A and Q for the result
    result = (A << n) | Q
    result_signed = from_twos_complement(result, 2 * n)

    print(f"Final Binary Result: {result:0{2*n}b}")
    print(f"Final Decimal Result: {result_signed}")
    return result_signed


# Example
m = input("Enter multiplicand (binary): ")  # e.g., 0110 for +6 or 1010 for -6 (4-bit)
q = input("Enter multiplier (binary): ")    # e.g., 0011 for +3 or 1101 for -3 (4-bit)
booth_multiplication(m, q)
